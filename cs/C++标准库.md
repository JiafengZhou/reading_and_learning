
---------2020-2-4-----------  
# 1.关于本书
# 2.C++及标准库简介
## C++标准的历史  
__cplusplus宏---对应C++语言的标准  
算法复杂度  
# 3.语言新特性
## C++11语言新特性
### nullptr取代0或者NULL  
NULL是define的0他俩等价而nullptr是void*  
auto完成自动类型推导  
### 一致性初始化和初始化列表 
初始化列表会强制值初始化  
列表初始化会检查初始化值窄化的问题，如果存在直接报错  
initializer_list<type>---初始化列表  
explicit 修饰的构造函数只能在构造函数中使用直接初始化，不能用赋值运算符  
普通构造函数可以被隐式调用，但是explicit只能被显示调用  
### Range based for 循环

### move语义和右值引用
右值引用，表明后面就不会再用这个临时变量了  
------------2020-2-5--------  
拷贝构造移动构造，拷构造需要将右值再拷贝一个副本到类中，而移动构造是将临时值直接用于初始化类的变量  
(1)void foo(int& in)
(2)void foo(int&& in)
(3)void foo(const int& in)
当只有(1)(2)的时候，对应左值跟右值正常对应  
没有(2)但是有(3),输入右值将由(3)传入，但是如果(2)如果跟(3)同时定义，就被(2)传入  
### 新式字符串字面值常量
### 关键字noexcept
修饰函数表示该函数没有或者不带算抛出异常  
### 关键字constexpr
### 崭新的Template特性
可以接收个数不定的模板参数  
递归调用  
带别名的模板  
### Lambda
可以把lambda当作内联函数使用  
[]中放外部引用参数，()中放输入实参  
指明返回类型   
[] ()->double {return 42}  
[=]值传递参数  
[&]引用传递参数  
通过值传递进去的参数是右值  
传值和传引用的混合体---mutable---非引用而是将值传递变量改为左值  
lambda表达式是没有名字的函数对象  
std::function<> class template  
### decltype
### 新的函数声明语法
### 带作用域的enumeration
### 新的基础类型
char_16t,char_32t  
long long;unsigned long long  
nullptr  
## 虽旧尤新的语言特性  
### 非类型模板参数
bitset<32>  
### 默认模板参数
### 关键字特typename
### 成员模板
类的成员可以是模板  
构造函数可以是模板的，这个时候如果类型相同，使用拷贝构造，如果类型不同，需要使用模板生成新类型的构造函数    

### 基础类型明确初始化
明确的构造函数调用但是没有实参，会给初始化为0  
### main()定义式
# 4.一般概念
## 命名空间std
std具有拓展性，可以自己定义放在std命名空间下  
## 头文件
## 差错和异常处理
### 标准异常类
针对逻辑错误设计的异常类  
针对运行时错误设计的异常类  
标准异常类和标准库中定义的异常类，为了代码可移植，最好使用标准异常类，因为标准库异常类会根据标准库的实现不同而变化  

exception---基准异常类  
stdexcept---大多数逻辑和运行时异常  
system_error---系统异常  
new---内存异常  
ios---io异常  
future---同步异常  
typeinfo---类型转换异常  
### 异常类的成员
成员函数what()---该函数返回的内容格式由编译器的实现决定  
处理差错码和差错状态  

## 可被调用对象
函数/指向函数的指针/函数对象/lambda表达式  
bind  
async  
## 并发跟多线程
## 分配器

# 5.通用工具
## pair和tuple
pair两个变量  
ref()引用变量  
tie()提取pair中的value值  

### tuple
----------2020-2-6----------  
explicit防止构造函数隐式类型转换  
对于tuple的初始化必须明确的将初值转化为tuple  

### tuple的输入输出
### tuple和pair的转换
## 智能指针
### shared_ptr














