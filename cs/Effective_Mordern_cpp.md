# 1.理解模板型别推导
## 实参类型是指针引用
## 实参类型是万能引用（右值引用）
## 实参类型非指针也非引用
# 2.理解auto型别推导
auto型别推导跟模板类型推导一致  
auto会假定大括号起来的初始化代表std::initializer_list  
# 3.理解decltype
声明表达式返回类型  
decltype(auto) 会将auto省略的修饰符填补出来  
# 4.掌握查看型别推导结果的方法  
IDE编辑器  
编译器错误提示  
typeid运行时name成员函数输出  
局限性---输出会会省略一部分  
boost-TyepIndex库会全部打印  
# 5.优先选择auto，而非显式型别声明
auto变量必须初始化  
# 6.当auto推导的型别不符合要求时，使用带显式型别的初始化物习惯用法 
隐式代理类型会导致auto类型推导错误，所以需要保证使用显式类型转换防止推导错误  
# 7.在创建对象时注意分别{}和()
大括号初始化对应的重载版本std::initializer_list具有优先匹配  
# 8.优先选用nullptr而非0或null
# 9.优先使用类型别名声明而非typedef
typedef不能模板化，类型别名可以
# 10.优先选用限定作用域的枚举类型而不是不限作用域的枚举类型
可以指定底层类型  
可以前置声明，这样，枚举改变不会使调用的其他部分重新编译  
# 11.优先选用删除函数而非private未定义函数
# 12.为意在改写的函数添加override声明
函数引用修饰词  

成员函数引用修饰符使得对左值和右值对象的处理能够区分开  
# 13.优先使用const_iterator而非iterator
在最通用的代码中优先选用非成员函数的begin等
# 14.只要函数不会发射异常，就为其加上noexcept声明
声明noexcept的函数可以得到更好的优化，但是必须保证不会发生异常
# 15.只要有可能使用constexpr，就要用它
constexpr对象时const的，在编译期已知切完成初始化  
constexpr函数传入的实参如果是编译期已知的，则产生编译期结果  
# 16.保证const成员函数的线程安全性
std::atomic 提供的性能好于互斥量，但是这个只能适用于单变量或内存区域，否则使用aomic不会保证线程安全  
# 17.理解特种函数的生成机制
特殊函数就是你没声明编译器自动为你生成的类成员函数  
编译器默认为类生成的函数之间存在影响
# 18.使用std::unique_ptr管理具备专属所有权的资源
unique_ptr转化为shared_ptr是容易实现的，所以工厂函数更适合返回unique_ptr，在调用者那里需要的时候再转化为shared_ptr
# 19.使用std::shared_ptr管理具备共享所有权的资源
支持指定删除器，删除器的型别对shared_ptr没有影响
# 20.对于类似于std::shared_ptr但有可能空悬的指针使用std::weak_ptr
weak_ptr可能的用武之地包括缓存，观察者列表，以及避免shared_ptr指针环路  
# 21.优先选用std::make_unique和std::make_shared而非直接使用new
常规使用make函数会获得更好的性能  
不建议使用make的场景包括：自定义内存管理的类，内存紧张的系统，对象又非常大以及比shared_ptr生存周期更长的weak_ptr
# 22.使用Pimpl习惯用法时，将特殊成员函数的定义放在实现文件中
pimpl编程手法可以降低客户与类实现之间的依赖，减少构建遍数  
使用unique_ptr作为pimpl的指针，应该注意默认函数实现的问题  
# 23.理解std::move和std::forward
move是无条件强制将对象转化为右值类型  
forward是输入是右值引用才转化为右值类型，如果是左值，就转化为左值类型  
# 24.区分万能引用和右值引用
如果函数模板具备T&& 形式，且T是推导出来的或者auto&& 这是万能引用，否则就是右值引用  
如果型别声明不精确具有type&& 形式，则是右值引用  
使用右值初始化万能引用得到右值引用，使用左值初始化万能引用得到左值引用  
# 25.针对右值引用实施std::move,针对万能引用实施std::forward
局部对象可能适用于返回值优化，切勿对其实施std::move或者std::forward  
# 26.避免依万能引用型别进行重载
万能引用型别在重载的时候，匹配优先级高，容易抢占正常的重载  
# 27.熟悉依万能引用型别进行重载的替代方案
舍弃重载  
传递const T&型别的形参  
传值  
标签分派---模板元编程  
对接收万能引用的模板施加限制  
enable_if,is_same,decay_t  
万能引用在性能上具备优势，但是在易用性上，如果接口输入类型不匹配，可能会打印出一大堆错误信息，尤其层层引用厚，不容易定位问题  
# 28.理解引用折叠
引用折叠会在模板实例化，auto型别生成，创建和运用typedef和别名声明，decltype  
# 29.假定移动操作不存在，成本高，未使用
# 30.熟悉完美转发失败的情形
导致完美转发失败的原因：大括号初始物，以0或null表达空指针，仅有声明的static_const成员变量，模板或者重载函数名字，位域
# 31.避免默认捕获模式
按引用的默认捕获会导致悬空指针的问题  
按值得默认捕获极易受到悬空指针影响，并且容易让人误以为自洽  
# 32.使用初始化捕获将对象移入闭包
# 33.对auto&&型别的形参使用decltype，以std::forward之

# 34.优先选用lambda表达式，而非std::bind
c++14中bind作用逐渐被lambda表达式取代  
# 35.优先选用基于任务而非基于线程的程序设计
std::thread没有提供直接获取运行函数返回值的途径，而且如果这些函数抛出异常，程序就会终止  
# 36.如果异步是必要的，则指定std::launch::async
async的默认启动策略既允许任务以异步方式执行，也允许任务以同步的方式执行  
如果异步是必要的，调用std::launch::async  
# 37.使std::thread 型别对象在所有路径皆不可联结
# 38.对变化多端的线程句柄析构函数行为保持关注
指涉经由std::aysnc启动的未推迟任务共享状态的最后一个期值会保持阻塞，知道任务结束  
# 39.考虑针对一次性事件通信使用以void为模板型别实参的期值
# 40.对并发使用std::atomic，对特种内存使用volatile
atomic用于多线程访问，不适用互斥量  
volatile用于读写操作不被编译期优化掉内存，是对特种内存使用的工具  
# 41.针对可复制形参，在移动成本低切一定会被复制的前提下，考虑将其按值传递

# 42.考虑置入而非插入
























