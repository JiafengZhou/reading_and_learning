# 1.理解模板型别推导
## 实参类型是指针引用
## 实参类型是万能引用（右值引用）
## 实参类型非指针也非引用
# 2.理解auto型别推导
auto型别推导跟模板类型推导一致  
auto会假定大括号起来的初始化代表std::initializer_list  
# 3.理解decltype
声明表达式返回类型  
decltype(auto) 会将auto省略的修饰符填补出来  
# 4.掌握查看型别推导结果的方法  
IDE编辑器  
编译器错误提示  
typeid运行时name成员函数输出  
局限性---输出会会省略一部分  
boost-TyepIndex库会全部打印  
# 5.优先选择auto，而非显式型别声明
auto变量必须初始化  
# 6.当auto推导的型别不符合要求时，使用带显式型别的初始化物习惯用法 
隐式代理类型会导致auto类型推导错误，所以需要保证使用显式类型转换防止推导错误  
# 7.在创建对象时注意分别{}和()
大括号初始化对应的重载版本std::initializer_list具有优先匹配  
# 8.优先选用nullptr而非0或null
# 9.优先使用类型别名声明而非typedef
typedef不能模板化，类型别名可以
# 10.优先选用限定作用域的枚举类型而不是不限作用域的枚举类型
可以指定底层类型  
可以前置声明，这样，枚举改变不会使调用的其他部分重新编译  
# 11.优先选用删除函数而非private未定义函数








