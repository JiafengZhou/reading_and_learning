# 1.理解模板型别推导
## 实参类型是指针引用
## 实参类型是万能引用（右值引用）
## 实参类型非指针也非引用
# 2.理解auto型别推导
auto型别推导跟模板类型推导一致  
auto会假定大括号起来的初始化代表std::initializer_list  
# 3.理解decltype
声明表达式返回类型  
decltype(auto) 会将auto省略的修饰符填补出来  
# 4.掌握查看型别推导结果的方法  
IDE编辑器  
编译器错误提示  
typeid运行时name成员函数输出  
局限性---输出会会省略一部分  
boost-TyepIndex库会全部打印  
# 5.优先选择auto，而非显式型别声明
auto变量必须初始化  
# 6.当auto推导的型别不符合要求时，使用带显式型别的初始化物习惯用法 
隐式代理类型会导致auto类型推导错误，所以需要保证使用显式类型转换防止推导错误  
# 7.在创建对象时注意分别{}和()
大括号初始化对应的重载版本std::initializer_list具有优先匹配  
# 8.优先选用nullptr而非0或null
# 9.优先使用类型别名声明而非typedef
typedef不能模板化，类型别名可以
# 10.优先选用限定作用域的枚举类型而不是不限作用域的枚举类型
可以指定底层类型  
可以前置声明，这样，枚举改变不会使调用的其他部分重新编译  
# 11.优先选用删除函数而非private未定义函数
# 12.为意在改写的函数添加override声明
函数引用修饰词  

成员函数引用修饰符使得对左值和右值对象的处理能够区分开  
# 13.优先使用const_iterator而非iterator
在最通用的代码中优先选用非成员函数的begin等
# 14.只要函数不会发射异常，就为其加上noexcept声明
声明noexcept的函数可以得到更好的优化，但是必须保证不会发生异常
# 15.只要有可能使用constexpr，就要用它
constexpr对象时const的，在编译期已知切完成初始化  
constexpr函数传入的实参如果是编译期已知的，则产生编译期结果  
# 16.保证const成员函数的线程安全性
std::atomic 提供的性能好于互斥量，但是这个只能适用于单变量或内存区域，否则使用aomic不会保证线程安全  
# 17.理解特种函数的生成机制
特殊函数就是你没声明编译器自动为你生成的类成员函数  
编译器默认为类生成的函数之间存在影响
# 18.使用std::unique_ptr管理具备专属所有权的资源
unique_ptr转化为shared_ptr是容易实现的，所以工厂函数更适合返回unique_ptr，在调用者那里需要的时候再转化为shared_ptr
# 19.使用std::shared_ptr管理具备共享所有权的资源
支持指定删除器，删除器的型别对shared_ptr没有影响
# 20.对于类似于std::shared_ptr但有可能空悬的指针使用std::weak_ptr
weak_ptr可能的用武之地包括缓存，观察者列表，以及避免shared_ptr指针环路  
# 21.优先选用std::make_unique和std::make_shared而非直接使用new
常规使用make函数会获得更好的性能  
不建议使用make的场景包括：自定义内存管理的类，内存紧张的系统，对象又非常大以及比shared_ptr生存周期更长的weak_ptr
# 22.使用Pimpl习惯用法时，将特殊成员函数的定义放在实现文件中
pimpl编程手法可以降低客户与类实现之间的依赖，减少构建遍数  
使用unique_ptr作为pimpl的指针，应该注意默认函数实现的问题  
# 23.理解std::move和std::forward
move是无条件强制将对象转化为右值类型  
forward是输入是右值引用才转化为右值类型，如果是左值，就转化为左值类型  
# 24.区分万能引用和右值引用
如果函数模板具备T&& 形式，且T是推导出来的或者auto&& 这是万能引用，否则就是右值引用  
如果型别声明不精确具有type&& 形式，则是右值引用  
使用右值初始化万能引用得到右值引用，使用左值初始化万能引用得到左值引用  
# 25.针对右值引用实施std::move,针对万能引用实施std::forward

























