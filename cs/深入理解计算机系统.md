# 第1章 计算机系统漫游
-------------------2020-1-9---------------
## 1.1 信息就是位+上下文
计算机系统中的信息实际上就是一堆二进制数，机器只认识二进制数，但是相同的二进制序列可能会表示不同的意义，而这些意义就是计算机系统中的各种概念。
## 1.2 程序被其他程序翻译成不同的格式
预处理-编译-汇编-链接
## 1.3 了解编译系统如何工作是有很大益处的
优化程序性能/理解链接时出现的错误/避免安全漏洞
## 1.4 处理器读取并解释存储在内存中的指令
系统的硬件组成---总线，I/O设备，主存，处理器
## 1.5 高速缓存至关重要
利用好高速缓存可以将应用程序提速很多倍
## 1.6 存储设备形成层次结构
存储区层次结构
## 1.7 操作系统管理硬件
进程，线程，虚拟内存，文件
## 1.8 系统之间利用网络进行通信
线程级并发  
指令级并行  
单指令多数据并行

# 2 信息的表示与处理
## 2.1 信息存储
### 十六进制表示法  
### 字数据大小  
### 寻址与字节顺序：大端法，小端法  
测试程序  
chapter1：
void show_bytes(byte_pointer start, size_t len);

void show_int(int x);

void show_float(float x);

void show_pointer(void* x);

void test_bytes();       //测试系统大段小端

### 表示字符串
### 表示代码
相同的C函数在不同的机器，会编译出不同的指令和编码方式
### 布尔代数
可以通过一些二进制布尔运算来表示数据集的交，并关系
### C语言中的位级运算
&，|，~，^
### C语言中的逻辑运算
&&，||，！
### C语言中的移位运算

## 2.2 整数表示
### 整型数据类型
### 无符号数编码
无符号数编码是唯一的
### 补码编码
补码编码是唯一的  
注意补码的计算公式  
### 符号数和无符号数之间的转换
### C语言中的有符号数与无符号数
-----------------2019-1-10-------------------
数据的二进制表述没有变，只是改变了编码表述，是补码还是无符号数
### 拓展一个数字的位表示
C语言将低字数无符号数据类型转换为大字数有符号数据类型，先扩充补码的二进制位数，用最高位填充，再用有符号数来解释
### 截断数字
无符号数截断需要用原来的无符号数模2的需要截断的位数次方  
有符号数截断：先使用无符号数的截断方法去截断数据，在将截断剩下的二进制数转化位有符号数表示
### 关于有符号数和无符号数的建议

## 2.3 整数运算
### 无符号加法
固定位数的算数加法有造成溢出的风险  
检测无符号数加法的溢出原理  
无符号数求反
### 补码加法
正溢出    
负溢出  
补码加法的溢出检测原理  
### 补码的非
补码的非
额外两种计算补码非的算法
### 无符号数乘法
### 补码乘法
无符号数乘法和补码乘法的位级等价
### 乘以常数
乘以2的幂的无符号数---左移  
乘以2的幂的补码---左移  
乘以任意整数---将其分解为多个2的指数幂次相加，依次左移相加相减
### 除以2的幂
无符号数右移除以2的k次幂，向下取整  
有符号数右移，使用算数移位，向下取整  
如果想求向上取整的结果，应该在移位之前加入一些偏移
### 关于整数运算的一些思考
越界很危险

## 2.4 浮点数
### 二进制小数
类似于十进制
### IEEE浮点表示
符号，尾数，阶码  
规格化的值，非规格化的值，特殊值---无穷大或NAN
### 数字表示
### 舍入
最近值舍入  
向零舍入  
向下舍入  
向上舍入  
### 浮点运算
浮点运算的乘法没有结合律和分配律
### C语言中的浮点数
C语言不强制要求机器满足IEEE浮点数标准  
-------------2020-1-11------------------  
# 3 程序的机器级表示
## 3.1 历史观点  
指令集在伴随硬件的发展更替，新的系统可以对以前的特性兼容，但是很多原来的指令集现在看都是过时的
## 3.2 程序编码
源代码->(预处理器)->替换宏的源代码->(编译器)->汇编代码->(汇编器)->目标代码->(连接器)->可执行文件
### 机器级代码
程序计数器---给出下一条要执行程序的地址  
整数寄存器文件---16个寄存器，用于存储地址或者整数数据  
条件码寄存器---保存最近执行的算术和逻辑指令的状态信息  
一组向量寄存器---存放一个或多个整数或浮点数  
### 代码示例
x86-64指令集长度从1-15不等，用的多的指令所占字节数少  
## 3.3 数据格式
汇编代码后面的后缀会指定传输数据的类型，占用的位数
## 3.4 访问信息
x86-64指令集：16个64位通用目的寄存器---存放整数和指针
### 操作数指示符
操作数分为：立即数，寄存器，内存引用  
各种寻址方式  
### 数据传送指令
move指令  
movez系列零拓展
moves系列符号拓展
### 数据传输示例
练习使用汇编代码往C源代码反向工程
### 压入和弹出栈数据
栈顶元素的地址是栈中元素地址最底的  
%rsp寄存器是存放栈指针的  
## 3.5 算数和逻辑操作
加载有效地址，一元操作，二元操作，移位  
### 加载有效地址
leap指令
### 一元和二元操作
### 移位操作
### 讨论
### 特殊的算数操作
-------------2020-1-12---------------------
128位乘法和除法的拓展运算  
%rdx作为高位，%rax作为低位  
## 3.6 控制
### 条件码
条件码寄存器  
ZF---零标志  
CF---进位标志  
SF---符号标志  
OF---溢出标志 

比较和测试指令组合

### 访问条件码
设置指令集
### 跳转指令 
跳转指令集
### 跳转指令的编码
相对寻址和绝对寻址(目测相对寻址用的多)
### 用条件控制来实现条件分支
正常逻辑判断跳转
### 用条件传送实现条件分支
因为现代处理器使用流水线技术，因此使用条件传输往往可以获得高性能，但是不绝对，因为条件传送会计算两种情况变量值，如果计算量比较大，就没有条件控制高效。
### 循环
do-while循环  
-----------------2020-1-13---------------  
while循环---两种翻译方法：跳转到中间；guarded do;  
for循环  

### switch语句
跳跃表  
## 3.7 过程
### 运行时栈
用栈来保存过程调用机制的参数
### 转移控制
call  
ret
使用栈来保存调用函数的数据，在被调用函数之间跳来跳去
### 数据传送
如果输入参数数量大于6，要使用栈来保存其他的输入参数，一个参数在地址上占据八位
### 栈上的局部存储
由于寄存器数量不足，局部变量使用&或者局部变量是数组或者结构，需要将变量放在内存中存储
### 寄存器中的局部存储空间
%rbx,%rbp,%12-%r15被调用者保存寄存器---调用过程必须为这些寄存器的数据提供栈空间存储或者在调用过程的过程中不改变这些寄存器的数据  
其他的寄存器除了%rsp之外叫做调用者保存寄存器，调用者必须为

## 3.8 数组分配和访问

### 基本原则
基本的指针索引
### 指针运算
### 嵌套数组
类似于数据结构中的表述
### 定长数组
------------------2020-1-14-------------  
定长数组O1项优化实际上是做了编译期计算，增加了编译期计算时间，但是降低了运行期计算时间。  
### 变长数组
GCC如果编译使用优化项，可以识别多维变长数组中的步长，产生的代码可以避免一些乘法计算，从而提高程序的性能。
## 3.9 异质的数据结构
### 结构
存储方式类似于指针，只不过内部类型可以不同，内部变量的引用可以在结构体指针的基础上加上偏移得到
### 联合
节省空间的方法
### 数据对齐
数据对齐可以提高内存系统性能：比如书如果不对齐，数据存在两个相邻的字节中，cpu需要从内存中取两次数据，分别是两个字节的高位数据和低位数据，拼起来，但是如果数据是对齐的，一次就可以取出，这样就提高了系统效率。当使用数据对齐时候，有时候需要做数据填充，来保证数据对齐。
## 3.10 在机器级程序中将控制与数据结合起来
### 理解指针
参考c primer plus
### 应用：使用GDB调试器

### 内存越界引用和缓冲区溢出
系统安全漏洞的重要来源
### 对抗缓冲区溢出攻击
栈随机化，栈破坏检测，限制可执行代码区域
### 支持变长栈帧
加了一个帧指针
## 3.11 浮点代码
MMX-SSE-AVX  
### 浮点传送和转换操作
--------------2020-1-15--------------
### 过程中的浮点代码
根据函数的输入参数的顺序和数量决定哪些参数在那个寄存器哪些参数在栈中
### 浮点运算操作
加减乘除最大最小平方
### 定义和使用浮点常数
### 浮点数代码中的位级操作
位级异或位级与
### 浮点比较操作
### 对浮点代码的观察结论

# 4 处理器体系结构
ISA指令集体系架构在编译器和处理器设计人员之间提供了抽象，编译器设计人员只需要知道指令集是那些，怎么编码，就可以用来设计编译器；而处理器设计人员只需要考虑将如何让处理器支持这些指令集就可；  

## 4.1 Y86-64指令集体系结构
### 程序员可见状态
### Y86-64指令
### 指令编码
### Y86-64异常
程序状态码标识程序运行状态
### Y86-64程序

## 4.2 逻辑设计和硬件控制语言HCL
### 逻辑门
与或非
### 组合电路何HCL布尔表达式
-----------------2020-1-16-------------
### 字级组合电路和HCL整数表达式
多路复用器，算数/逻辑单元
### 集合关系
### 存储器和时钟
寄存器的状态在输入发生变化后，时钟信号的上升沿发生，导致寄存器状态发生变化  

寄存器文件可以由时钟控制，对内存进行读写数据交换
## 4.3 Y86-64顺序实现
为后面实现高效流水线化的处理器奠定基础
### 将处理器组织成阶段
取指，译码，执行，访存，写回，更新


# 5 程序性能优化
编写高效程序需要注意事项：  
（1）选择合适的算法和数据结构  
（2）理解编译器的能力和局限性  
（3）将一个任务分成多个部分，多核多处理器并行计算   需要在性能，代码简洁性，可读性之间做取舍  
## 5.1优化编译器能力和局限性
安全优化必须保证两个代码具有一样的行为  
内存别名使用  

使用内联函数替换进行函数优化
## 5.2 表示程序性能
每元素周期数CPE表示程序性能
## 5.3 程序示例
## 5.4 消除循环的低效率
循环中有一些是重复计算的，可以考虑将其一次计算出来，所谓自动变量，直接索引，较少无效计算次数---代码移动编程技巧  
## 5.5 减少调用过程
将一些函数调用移到循环外面，减少函数调用次数，可以一定程度上提高程序的效率，但是这样也造成了破坏代码模块化问题，需要程序员做一些取舍。
## 5.6 消除不必要的内存引用
频繁访问内存的可以用一个自动变量放在寄存器中访问修改，在计算完后，放入内存中  
## 5.7 理解现代处理器
延迟界限---并行指令但是表现出顺序执行所造成一些指令等待另外一些指令执行完成的界限  
吞吐界限---处理器理论上限  
### 整体操作
---------------2020-1-17---------------
将机器级指令分解成不同部分，提高指令并行执行能力，同时使用退役单元，保证乱序处理可以在宏观上按照顺序去执行。
### 功能单元性能
加法乘法计算快占用时钟周期短，除法占用时钟周期长  
### 处理器操作的抽象模型
使用数据流分析程序性能，关键路径是决定程序性能的决定性因素  
分析程序执行的关键路径，又时候可以让计算量更大的程序跑出更快的效果  
## 5.8 循环展开
O3或更高等级编译器优化选项会执行循环展开优化  
## 5.9 提高并行性
### 多个累积变量
整数累乘和累加是可以分解组合的，使用多个寄存器彼此数据不相关，可以并行执行程序计算，提高程序吞吐量  
浮点数的乘法和加法不可结合，因为存在舍入误差，但是现实情况是要在精度有所损失和计算性能提升之间做权衡  
### 重新结合变换
会带来并行加速效果  
SIMD
## 5.10 优化合并代码的结果小结
现代处理器具有很强的计算能力，但是需要编写不同于常规的代码才能诱导出这种性能  
## 5.11 一些限制因素
关键路径指明了程序执行时间的基本下限  
### 寄存器溢出
用于并行计算的寄存器数量有限，如果并行程度过高，会把变量放在内存中保存  
维护大量存储在内存栈中的数据做并行会降低程序的性能  
### 分支预测和预测错误处罚
书写适合条件传送实现的代码  
## 5.12 理解内存性能
### 加载的性能
### 存储的性能
访问内存会慢一些，如果迭代前一步与后一步没有数据依赖性，会较快完成。但是有数据依赖关系，就必须等待前面的数据完成传输更改，再进行下一步操作。
## 5.13 应用：性能提高技术
对于高度优化的代码要更加警惕代码优化带来的程序潜在风险，做更多的测试

## 5.14 确认和消除性能瓶颈
代码剖析程序---在大的程序中使用数据分析代码哪部分占用时间多，确定优化可以为整体带来较大性能提升的部分

### 程序剖析
unix有程序性能分析工具GPROF；  
此工具对较短的函数运行时间测量不是特别准确，1s左右为估计值，如果时间很长，可以认为是比较准确的，它是假设没有使用内联的，因为如果使用内联，函数的调用次数统计就不准确了，代码都被展开进入了函数，无法统计出实际被调用了多少次。
### 使用剖析程序指导优化
------------2020-1-18--------------  
除了使用性能分析工具，还应该注意测试的基准数据，要跟实际应用相吻合，还要考虑极限情况

# 6 存储器层次结构
存储器具有层次结构，高效的程序需要让程序更好的访问速度更快的存储器。  
## 6.1存储技术
存储技术发展快速  
### 随机访问存储器
静态随机访问存储器SRAM，动态随机访问存储器DRAM  
传统的DRAM  
增强DRAM---基本原理仍然是传统DRAM    
内存模块  
非易失性存储器  
### 磁盘存储
磁盘构造  
磁盘容量  
磁盘操作  
连接I/O设备  
访问磁盘  
### 固态硬盘
速度快于机械硬盘
### 存储技术的趋势
存储越来越便宜
## 6.2 局部性
时间局部性原理和空间局部性原理  
### 对程序数据引用的局部性
### 取指的局部性
## 6.3 存储器层次结构
### 存储器层次结构中的缓存
缓存命中/缓存不命中  
缓存不命中种类：冷不命中，冲突不命中  
缓存管理  
### 存储器层次结构概念小结
利用时间局部性---重复使用最近使用的变量  
利用空间局部性---使用调用变量附近的变量  
## 6.4高速缓存存储器
### 通用的高速缓存存储器组织结构
------------2020-1-19---------------  
### 直接映射高速缓存
一组只有一行  
需要了解查询命中不命中替换的过程  
"高速缓存抖动"现象的解决方案  
### 组相联高速缓存
一组由多行
### 全相联高速缓存
只有一组，具有很多行  
### 有关写的问题
直写，回写  
### 一个真实高速缓存层次结构的解剖 
### 高速缓存参数的性能分析
## 6.5 编写高速缓存友好代码
写代码一定要注意对缓存友好，可以提高代码的执行效率
## 6.6 综述：高速缓存对程序性能的影响
### 存储器山
性能不同的各级缓存  
描述存储器系统的整体性能  
### 重新排列循环以提高空间局部性

# 7 链接
将多个代码和数据片收集合并成单一的文件过程
## 7.1 编译器驱动程序
一步一步将源代码转换为汇编代码，在转换为目标代码有连接器组成可执行文件
## 7.2 静态链接
-------------2020-1-20---------------  
链接器的两大任务---符号解析和重定位  
## 7.3 目标文件
可重定位目标文件  
可执行目标文件  
共享目标文件  

linux和unix使用ELF目标文件  
## 7.4 可重定位的目标文件
ELF头，节，节头部表  
## 7.5 符号和符号表
给外部模块使用的全局符号，从外部引用的外部符号，本模块内部使用的内部符号  
## 7.6 符号解析
链接器解析符号引用的方法---将符号引用跟输入的可重定位目标文件的符号表中的一个确定的符号定义关联  
### 链接器如何解析多重定义的全局符号
不允许多个同名的强符号  
如果有一个强符号和多个弱符号同名，选择强符号  
如果有多个弱符号同名，从众多的弱符号中选择一个  
### 与静态库链接
静态库是一堆可重定位目标文件的集合，静态链接可执行文件时候，将可执行文件中引用的函数所在的目标文件拷贝到可执行文件中。  
### 链接器如何使用静态库来解析引用
链接器使用静态库进行解析引用的时候，需要注意库之间的依赖关系和顺序
## 7.7 重定位
将多个目标文件中的节合并，每条指令和全局变量都有唯一的运行时地址，修改代码节和数据节中对应符号运行时的内存地址。  
### 重定位条目
-----------2020-1-21------------------  
注意这个数据结构
### 重定位符号引用
------2020-1-24-----------------------  
重定位相对引用和重定位绝对引用  
## 7.8 可执行目标文件
大部分结构跟可重定位目标文件类似，但是得看链接什么库，注意载入过程跟链接过程的区别
## 7.9 加载可执行目标文件
可执行文件的内存映像  
## 7.10 动态链接共享库
使用动态链接器实现动态链接  
## 7.11 从应用程序中加载和链接共享库
linux提供专门的函数用于打开共享库使用里面的符号  
## 7.12 位置无关代码 
多个运行中的进程共享内存中的库代码  

PIC数据引用和PIC函数调用看的不是太明白
## 7.13 库打桩机制
创建包装函数，跟库函数声明相同，在运行时，运行包装函数的实现而非库的实现。


























