# 第1章 计算机系统漫游
-------------------2020-1-9---------------
## 1.1 信息就是位+上下文
计算机系统中的信息实际上就是一堆二进制数，机器只认识二进制数，但是相同的二进制序列可能会表示不同的意义，而这些意义就是计算机系统中的各种概念。
## 1.2 程序被其他程序翻译成不同的格式
预处理-编译-汇编-链接
## 1.3 了解编译系统如何工作是有很大益处的
优化程序性能/理解链接时出现的错误/避免安全漏洞
## 1.4 处理器读取并解释存储在内存中的指令
系统的硬件组成---总线，I/O设备，主存，处理器
## 1.5 高速缓存至关重要
利用好高速缓存可以将应用程序提速很多倍
## 1.6 存储设备形成层次结构
存储区层次结构
## 1.7 操作系统管理硬件
进程，线程，虚拟内存，文件
## 1.8 系统之间利用网络进行通信
线程级并发  
指令级并行  
单指令多数据并行

# 2 信息的表示与处理
## 2.1 信息存储
### 十六进制表示法  
### 字数据大小  
### 寻址与字节顺序：大端法，小端法  
测试程序  
chapter1：
void show_bytes(byte_pointer start, size_t len);

void show_int(int x);

void show_float(float x);

void show_pointer(void* x);

void test_bytes();       //测试系统大段小端

### 表示字符串
### 表示代码
相同的C函数在不同的机器，会编译出不同的指令和编码方式
### 布尔代数
可以通过一些二进制布尔运算来表示数据集的交，并关系
### C语言中的位级运算
&，|，~，^
### C语言中的逻辑运算
&&，||，！
### C语言中的移位运算

## 2.2 整数表示
### 整型数据类型
### 无符号数编码
无符号数编码是唯一的
### 补码编码
补码编码是唯一的  
注意补码的计算公式  
### 符号数和无符号数之间的转换
### C语言中的有符号数与无符号数
-----------------2019-1-10-------------------
数据的二进制表述没有变，只是改变了编码表述，是补码还是无符号数
### 拓展一个数字的位表示
C语言将低字数无符号数据类型转换为大字数有符号数据类型，先扩充补码的二进制位数，用最高位填充，再用有符号数来解释
### 截断数字
无符号数截断需要用原来的无符号数模2的需要截断的位数次方  
有符号数截断：先使用无符号数的截断方法去截断数据，在将截断剩下的二进制数转化位有符号数表示
### 关于有符号数和无符号数的建议

## 2.3 整数运算
### 无符号加法
固定位数的算数加法有造成溢出的风险  
检测无符号数加法的溢出原理  
无符号数求反
### 补码加法
正溢出    
负溢出  
补码加法的溢出检测原理  
### 补码的非
补码的非
额外两种计算补码非的算法
### 无符号数乘法
### 补码乘法
无符号数乘法和补码乘法的位级等价
### 乘以常数
乘以2的幂的无符号数---左移  
乘以2的幂的补码---左移  
乘以任意整数---将其分解为多个2的指数幂次相加，依次左移相加相减
### 除以2的幂
无符号数右移除以2的k次幂，向下取整  
有符号数右移，使用算数移位，向下取整  
如果想求向上取整的结果，应该在移位之前加入一些偏移
### 关于整数运算的一些思考
越界很危险

## 2.4 浮点数
### 二进制小数
类似于十进制
### IEEE浮点表示
符号，尾数，阶码  
规格化的值，非规格化的值，特殊值---无穷大或NAN
### 数字表示
### 舍入
最近值舍入  
向零舍入  
向下舍入  
向上舍入  
### 浮点运算
浮点运算的乘法没有结合律和分配律
### C语言中的浮点数
C语言不强制要求机器满足IEEE浮点数标准  
-------------2020-1-11------------------  
# 3 程序的机器级表示
## 3.1 历史观点  
指令集在伴随硬件的发展更替，新的系统可以对以前的特性兼容，但是很多原来的指令集现在看都是过时的
## 3.2 程序编码
源代码->(预处理器)->替换宏的源代码->(编译器)->汇编代码->(汇编器)->目标代码->(连接器)->可执行文件
### 机器级代码
程序计数器---给出下一条要执行程序的地址  
整数寄存器文件---16个寄存器，用于存储地址或者整数数据  
条件码寄存器---保存最近执行的算术和逻辑指令的状态信息  
一组向量寄存器---存放一个或多个整数或浮点数  
### 代码示例
x86-64指令集长度从1-15不等，用的多的指令所占字节数少  
## 3.3 数据格式
汇编代码后面的后缀会指定传输数据的类型，占用的位数
## 3.4 访问信息
x86-64指令集：16个64位通用目的寄存器---存放整数和指针
### 操作数指示符
操作数分为：立即数，寄存器，内存引用  
各种寻址方式  
### 数据传送指令
move指令  
movez系列零拓展
moves系列符号拓展
### 数据传输示例
练习使用汇编代码往C源代码反向工程
### 压入和弹出栈数据
栈顶元素的地址是栈中元素地址最底的  
%rsp寄存器是存放栈指针的  
## 3.5 算数和逻辑操作
加载有效地址，一元操作，二元操作，移位  
### 加载有效地址
leap指令
### 一元和二元操作
### 移位操作
### 讨论
### 特殊的算数操作
-------------2020-1-12---------------------
128位乘法和除法的拓展运算  
%rdx作为高位，%rax作为低位  
## 3.6 控制
### 条件码
条件码寄存器  
ZF---零标志  
CF---进位标志  
SF---符号标志  
OF---溢出标志 

比较和测试指令组合

### 访问条件码
设置指令集
### 跳转指令 
跳转指令集
### 跳转指令的编码
相对寻址和绝对寻址(目测相对寻址用的多)
### 用条件控制来实现条件分支
正常逻辑判断跳转
### 用条件传送实现条件分支
因为现代处理器使用流水线技术，因此使用条件传输往往可以获得高性能，但是不绝对，因为条件传送会计算两种情况变量值，如果计算量比较大，就没有条件控制高效。
### 循环
do-while循环  
-----------------2020-1-13---------------  
while循环---两种翻译方法：跳转到中间；guarded do;  
for循环  

### switch语句
跳跃表  
## 3.7 过程
### 运行时栈
用栈来保存过程调用机制的参数
### 转移控制
call  
ret
使用栈来保存调用函数的数据，在被调用函数之间跳来跳去
### 数据传送
如果输入参数数量大于6，要使用栈来保存其他的输入参数，一个参数在地址上占据八位
### 栈上的局部存储
由于寄存器数量不足，局部变量使用&或者局部变量是数组或者结构，需要将变量放在内存中存储
### 寄存器中的局部存储空间
%rbx,%rbp,%12-%r15被调用者保存寄存器---调用过程必须为这些寄存器的数据提供栈空间存储或者在调用过程的过程中不改变这些寄存器的数据  
其他的寄存器除了%rsp之外叫做调用者保存寄存器，调用者必须为

## 3.8 数组分配和访问

### 基本原则
基本的指针索引
### 指针运算
### 嵌套数组
类似于数据结构中的表述
### 定长数组
------------------2020-1-14-------------  
定长数组O1项优化实际上是做了编译期计算，增加了编译期计算时间，但是降低了运行期计算时间。  
### 变长数组
GCC如果编译使用优化项，可以识别多维变长数组中的步长，产生的代码可以避免一些乘法计算，从而提高程序的性能。
## 3.9 异质的数据结构
### 结构
存储方式类似于指针，只不过内部类型可以不同，内部变量的引用可以在结构体指针的基础上加上偏移得到
### 联合
节省空间的方法
### 数据对齐
数据对齐可以提高内存系统性能：比如书如果不对齐，数据存在两个相邻的字节中，cpu需要从内存中取两次数据，分别是两个字节的高位数据和低位数据，拼起来，但是如果数据是对齐的，一次就可以取出，这样就提高了系统效率。当使用数据对齐时候，有时候需要做数据填充，来保证数据对齐。
## 3.10 在机器级程序中将控制与数据结合起来
### 理解指针
参考c primer plus
### 应用：使用GDB调试器

### 内存越界引用和缓冲区溢出
系统安全漏洞的重要来源
### 对抗缓冲区溢出攻击
栈随机化，栈破坏检测，限制可执行代码区域
### 支持变长栈帧
加了一个帧指针
## 3.11 浮点代码
MMX-SSE-AVX  
### 浮点传送和转换操作
--------------2020-1-15--------------
### 过程中的浮点代码
根据函数的输入参数的顺序和数量决定哪些参数在那个寄存器哪些参数在栈中
### 浮点运算操作
加减乘除最大最小平方
### 定义和使用浮点常数
### 浮点数代码中的位级操作
位级异或位级与
### 浮点比较操作
### 对浮点代码的观察结论

# 4 处理器体系结构
ISA指令集体系架构在编译器和处理器设计人员之间提供了抽象，编译器设计人员只需要知道指令集是那些，怎么编码，就可以用来设计编译器；而处理器设计人员只需要考虑将如何让处理器支持这些指令集就可；  

## 4.1 Y86-64指令集体系结构
### 程序员可见状态
### Y86-64指令
### 指令编码
### Y86-64异常
程序状态码标识程序运行状态
### Y86-64程序

## 4.2 逻辑设计和硬件控制语言HCL
### 逻辑门
与或非
### 组合电路何HCL布尔表达式
-----------------2020-1-16-------------
### 字级组合电路和HCL整数表达式
多路复用器，算数/逻辑单元
### 集合关系
### 存储器和时钟
寄存器的状态在输入发生变化后，时钟信号的上升沿发生，导致寄存器状态发生变化  

寄存器文件可以由时钟控制，对内存进行读写数据交换
## 4.3 Y86-64顺序实现
为后面实现高效流水线化的处理器奠定基础
### 将处理器组织成阶段
取指，译码，执行，访存，写回，更新


# 5 程序性能优化
编写高效程序需要注意事项：  
（1）选择合适的算法和数据结构  
（2）理解编译器的能力和局限性  
（3）将一个任务分成多个部分，多核多处理器并行计算   需要在性能，代码简洁性，可读性之间做取舍  
## 5.1优化编译器能力和局限性
安全优化必须保证两个代码具有一样的行为  
内存别名使用  

使用内联函数替换进行函数优化
## 5.2 表示程序性能
每元素周期数CPE表示程序性能
## 5.3 程序示例
## 5.4 消除循环的低效率
循环中有一些是重复计算的，可以考虑将其一次计算出来，所谓自动变量，直接索引，较少无效计算次数---代码移动编程技巧  
## 5.5 减少调用过程
将一些函数调用移到循环外面，减少函数调用次数，可以一定程度上提高程序的效率，但是这样也造成了破坏代码模块化问题，需要程序员做一些取舍。
## 5.6 消除不必要的内存引用
频繁访问内存的可以用一个自动变量放在寄存器中访问修改，在计算完后，放入内存中  
## 5.7 理解现代处理器
延迟界限---并行指令但是表现出顺序执行所造成一些指令等待另外一些指令执行完成的界限  
吞吐界限---处理器理论上限  
### 整体操作
---------------2020-1-17---------------
将机器级指令分解成不同部分，提高指令并行执行能力，同时使用退役单元，保证乱序处理可以在宏观上按照顺序去执行。
### 功能单元性能
加法乘法计算快占用时钟周期短，除法占用时钟周期长  
### 处理器操作的抽象模型
使用数据流分析程序性能，关键路径是决定程序性能的决定性因素  
分析程序执行的关键路径，又时候可以让计算量更大的程序跑出更快的效果  
## 5.8 循环展开
O3或更高等级编译器优化选项会执行循环展开优化  
## 5.9 提高并行性
### 多个累积变量
整数累乘和累加是可以分解组合的，使用多个寄存器彼此数据不相关，可以并行执行程序计算，提高程序吞吐量  
浮点数的乘法和加法不可结合，因为存在舍入误差，但是现实情况是要在精度有所损失和计算性能提升之间做权衡  
### 重新结合变换
会带来并行加速效果  
SIMD
## 5.10 优化合并代码的结果小结
现代处理器具有很强的计算能力，但是需要编写不同于常规的代码才能诱导出这种性能  
## 5.11 一些限制因素
关键路径指明了程序执行时间的基本下限  
### 寄存器溢出
用于并行计算的寄存器数量有限，如果并行程度过高，会把变量放在内存中保存  
维护大量存储在内存栈中的数据做并行会降低程序的性能  
### 分支预测和预测错误处罚
书写适合条件传送实现的代码  
## 5.12 理解内存性能
### 加载的性能
### 存储的性能
访问内存会慢一些，如果迭代前一步与后一步没有数据依赖性，会较快完成。但是有数据依赖关系，就必须等待前面的数据完成传输更改，再进行下一步操作。
## 5.13 应用：性能提高技术
对于高度优化的代码要更加警惕代码优化带来的程序潜在风险，做更多的测试

## 5.14 确认和消除性能瓶颈
代码剖析程序---在大的程序中使用数据分析代码哪部分占用时间多，确定优化可以为整体带来较大性能提升的部分

### 程序剖析
unix有程序性能分析工具GPROF；  
此工具对较短的函数运行时间测量不是特别准确，1s左右为估计值，如果时间很长，可以认为是比较准确的，它是假设没有使用内联的，因为如果使用内联，函数的调用次数统计就不准确了，代码都被展开进入了函数，无法统计出实际被调用了多少次。
### 使用剖析程序指导优化
------------2020-1-18--------------  
除了使用性能分析工具，还应该注意测试的基准数据，要跟实际应用相吻合，还要考虑极限情况

# 6 存储器层次结构
存储器具有层次结构，高效的程序需要让程序更好的访问速度更快的存储器。  
## 6.1存储技术
存储技术发展快速  
### 随机访问存储器
静态随机访问存储器SRAM，动态随机访问存储器DRAM  
传统的DRAM  
增强DRAM---基本原理仍然是传统DRAM    
内存模块  
非易失性存储器  
### 磁盘存储
磁盘构造  
磁盘容量  
磁盘操作  
连接I/O设备  
访问磁盘  
### 固态硬盘
速度快于机械硬盘
### 存储技术的趋势
存储越来越便宜
## 6.2 局部性
时间局部性原理和空间局部性原理  
### 对程序数据引用的局部性
### 取指的局部性
## 6.3 存储器层次结构
### 存储器层次结构中的缓存
缓存命中/缓存不命中  
缓存不命中种类：冷不命中，冲突不命中  
缓存管理  
### 存储器层次结构概念小结
利用时间局部性---重复使用最近使用的变量  
利用空间局部性---使用调用变量附近的变量  
## 6.4高速缓存存储器
### 通用的高速缓存存储器组织结构
------------2020-1-19---------------  
### 直接映射高速缓存
一组只有一行  
需要了解查询命中不命中替换的过程  
"高速缓存抖动"现象的解决方案  
### 组相联高速缓存
一组由多行
### 全相联高速缓存
只有一组，具有很多行  
### 有关写的问题
直写，回写  
### 一个真实高速缓存层次结构的解剖 
### 高速缓存参数的性能分析
## 6.5 编写高速缓存友好代码
写代码一定要注意对缓存友好，可以提高代码的执行效率
## 6.6 综述：高速缓存对程序性能的影响
### 存储器山
性能不同的各级缓存  
描述存储器系统的整体性能  
### 重新排列循环以提高空间局部性

# 7 链接
将多个代码和数据片收集合并成单一的文件过程
## 7.1 编译器驱动程序
一步一步将源代码转换为汇编代码，在转换为目标代码有连接器组成可执行文件
## 7.2 静态链接
-------------2020-1-20---------------  
链接器的两大任务---符号解析和重定位  
## 7.3 目标文件
可重定位目标文件  
可执行目标文件  
共享目标文件  

linux和unix使用ELF目标文件  
## 7.4 可重定位的目标文件
ELF头，节，节头部表  
## 7.5 符号和符号表
给外部模块使用的全局符号，从外部引用的外部符号，本模块内部使用的内部符号  
## 7.6 符号解析
链接器解析符号引用的方法---将符号引用跟输入的可重定位目标文件的符号表中的一个确定的符号定义关联  
### 链接器如何解析多重定义的全局符号
不允许多个同名的强符号  
如果有一个强符号和多个弱符号同名，选择强符号  
如果有多个弱符号同名，从众多的弱符号中选择一个  
### 与静态库链接
静态库是一堆可重定位目标文件的集合，静态链接可执行文件时候，将可执行文件中引用的函数所在的目标文件拷贝到可执行文件中。  
### 链接器如何使用静态库来解析引用
链接器使用静态库进行解析引用的时候，需要注意库之间的依赖关系和顺序
## 7.7 重定位
将多个目标文件中的节合并，每条指令和全局变量都有唯一的运行时地址，修改代码节和数据节中对应符号运行时的内存地址。  
### 重定位条目
-----------2020-1-21------------------  
注意这个数据结构
### 重定位符号引用
------2020-1-24-----------------------  
重定位相对引用和重定位绝对引用  
## 7.8 可执行目标文件
大部分结构跟可重定位目标文件类似，但是得看链接什么库，注意载入过程跟链接过程的区别
## 7.9 加载可执行目标文件
可执行文件的内存映像  
## 7.10 动态链接共享库
使用动态链接器实现动态链接  
## 7.11 从应用程序中加载和链接共享库
linux提供专门的函数用于打开共享库使用里面的符号  
## 7.12 位置无关代码 
多个运行中的进程共享内存中的库代码  

PIC数据引用和PIC函数调用看的不是太明白
## 7.13 库打桩机制
创建包装函数，跟库函数声明相同，在运行时，运行包装函数的实现而非库的实现。

# 8 异常控制流
异常控制流是应用程序与操作系统交互的重要工具

## 8.1 异常
异常就是控制流的突变，来响应处理器状态的某些改变  
### 异常处理
硬件和软件组合使用，硬件提供异常表及相关寄存器  
### 异常的类别
中断---异步，返回到下一条指令  
陷阱---系统调用，同步，返回到下一条指令  
故障---错误引起，且可修复，同步，返回到当前指令  
终止---同步，不可修复，不会返回  

### Linux/x86-64系统中的异常

## 8.2 进程
### 逻辑控制流
### 并发流
并发与并行的基本概念
### 私有地址空间
linux具有通用结构
### 用户模式和内核模式
处理器控制寄存器的模式位，设置模式位就进入内核态，可以运行所有的指令，可以访问所有的内存空间；没有设置模式位，就只能使用有限的指令集，访问有限的访问空间，需要调用系统调用才能访问做权限不足的事情  
### 上下文切换
--------------2020-1-25----------------  
实现多任务的基本方法
## 8.3 系统调用错误处理
错误处理包装函数---简化代码，防止代码臃肿  
## 8.4 进程控制
获取进程ID---getpid()获取调用进程ID，getppid()获取调用进程父进程ID  

信号是软件中断  

exit(int status)以status状态退出  
fork()创建子进程  
### 回收子进程
waitpid()---等待子进程终止或停止  
wait()---等价于waitpid(-1.&status,0)

### 让进程休眠
------------2020-1-26-----------------------  
sleep()---将进程挂起一段时间  
pause()---让调用函数休眠，直到进程收到一个信号  
### 加载并运行程序
getenv()---在环境变量数组中寻找指定变量，成功返回指针，不成功返回NULL  
setenv()---设置环境变量  

## 8.5 信号
每种信号都对应一种系统事件，底层硬件异常是由内核的异常处理程序处理的。  

### 信号术语
发送信号---内核改变目的进程的状态(包括显式使用kill)  
接收信号---内核强迫目的进程对信号做出反应  

### 发送信号
进程组---getpgrp()---获取当前进程所在进程组  
setpid()---改变指定进程的进程组  
使用/bin/kill程序发送信号  

### 接收信号
errno()---记录系统最后一次出错代码  
安全的信号处理  
正确的信号处理  
--------2020-1-27------------------  
可移植的信号处理---在一些老版本的UNIX中，signal的语义不同；慢速系统调用情况，需要程序员自己手动被中断的系统调用代码  
sigaction()---用户设置信号处理的程序时，明确指出信号处理的语义---定义在bits文件中  
### 同步流以避免讨厌的并发错误
避免竞争导致的难以调试错误  
### 显式的等待信号
sigsuspend(mask)---函数暂时用mask替换当前的阻塞组合  
## 8.6 非本地跳转  

------2020-1-28-----------------  
# 9 虚拟内存
## 9.1 物理与虚拟地址
物理寻址  
虚拟寻址  
## 9.2 地址空间
物理地址空间/虚拟地址空间
## 9.3 虚拟内存作为缓冲工具
### DRAM缓存的组织结构
把内存作为磁盘的高速缓存  
### 页表
存放虚拟内存页和内存物理地址或者磁盘地址的对应关系  
### 页命中
cpu通过地址翻译硬件，到页表中寻找指定的页，如果有效位是1，则直接通过表找到内存中的物理地址  
### 缺页
cpu需要的页在磁盘中不在内存中，需要调度程序从磁盘中获取页，替换掉内存中的页。  
### 分配页面
在磁盘中建立页，需要的时候再调入内存  
### 又是局部性救了我们  
## 9.4 虚拟内存作为内存管理的工具
多个虚拟页可以映射到一个共享物理页上  
简化链接，加载，共享，内存分配  
## 9.5 虚拟内存作为内存的保护工具
再虚拟内存页表中，加入权限，读写能力的符号位，来确定权限，如果超越权限，就调用异常处理程序  
## 9.6 地址翻译
地址翻译的逻辑过程  
### 结合高速缓存和虚拟内存
地址翻译发生在高速缓存查找之前  
### 利用TLB加速地址翻译 
再内存管理单元内部加了一个PTE缓存  
### 多级页表
压缩页表再内存中的占用空间  
### 综合端到端的地址翻译
一个手工操作例子  
## 9.7 案例研究：Intel Corei7/Linux内存系统
### corei7地址翻译
### Linux虚拟内存系统
----------2020-1-29----------------  
linux一个进程的虚拟内存结构  
linux缺页异常处理  
## 9.8 内存映射
将虚拟内存区域跟磁盘对象关联，初始化这个虚拟内存区域，初始化虚拟内存区域内容  

### 共享对象
多个进程公共使用  
写时复制  
### 再看fork函数
充分利用共享和写时复制机制
### 再看execve函数
把新执行的程序的各个部分向原来的调用进程中映射  
### 使用mmap函数的用户级内存映射
## 9.9 动态内存分配
### malloc和free函数
malloc，calloc，realloc，free  
### 为什么使用动态内存分配分配
动态申请空间，如果写死程序，会给大型软件的维护带来巨大的挑战  
### 分配器的要求和目标
最大化吞吐量，最大化内存利用率
### 碎片
内部碎片  
外部碎片
### 实现问题
空闲块的组织，放置，分割，合并
### 隐式空闲链表
注意隐式空闲链表的结构，包括对齐等
### 放置已分配的块
放置策略---首次适配，下次适配，最佳适配
### 分割空闲块
### 获取额外堆内存
当残存所有的空闲块总和还是不够一次分配，就向内核申请一个更大的块。
### 合并空闲块
立即合并  
推迟合并
### 带边界标记的合并
四种合并情况  
---------------2020-1-30-------------------
### 综合：实现一个简单的分配器
### 显式空闲链表
显式空闲链表可以降低首次适配的分配时间
### 分离的空闲链表
进一步降低寻找空闲链表所用的时间  
简单分离存储  
分离适配---接近最佳性能同时兼顾吞吐量和内存利用率  
伙伴系统---大小类的大小是2的指数次  
## 9.10 垃圾收集
动态回收已经分配但是不同的堆空间
### 垃圾收集器的基本知识
垃圾收集器
### Mark&Sweep垃圾收集器
标记---将所有已经分配的可以从根节点查找到的做标记  
清除---将所有已经分配但是没有标记的节点当作垃圾清除掉  
### C程序的保守Mark & Sweep
C里面没有专门给指针的类型，所以会采用保守的方法，对一些垃圾不能准确识别出来  
## 9.11 C程序中常见的与内存有关的错误
### 间接引用坏指针
指针引用的位置不是你预期的位置，造成各种莫名其妙的错误出来
### 读取未初始化内存
未初始化的全局变量会被默认初始化为0，但是动态内存开辟出来的空间的元素不会被默认初始化。
### 允许栈缓冲区溢出
输入数据超过缓冲区的长度
### 假设指针和它们指向的对象是相同大小的
指针再指定系统中是有固定大小的，类型也是，二者不完全相同  
### 造成错位错误
### 引用指针而不是它指向的对象
### 误解指针计算
### 引用不存在的变量
### 引用空闲堆块中的数据
### 引起内存泄漏
# 10 系统级I/O
I/O就是从主存到外部设备之间复制数据的过程  
## Unix I/O
所有的I/O设备再linux中都被模型化为文件，所有的输入和输出都被看做相应文件的读写来执行  

打开文件  
linux shell为每个进程打开了stdout，stdin，stderr  
改变当前的文件位置  
读写文件  
关闭文件
## 文件
普通文件---文本文件/二进制文件  
目录  
socket  
相对路径/绝对路径  
## 打开和关闭文件
open()---文件名，如何访问文件，文件的访问权限   
close()---关闭文件  
### 读和写文件
应用程序是通过write和read来对文件输入和输出的  
## 用RIO包健壮的读写
### RIO的无缓存的输入输出函数
在系统函数上做的包装，加入了信号处理  
### RIO的带缓冲的输入函数
在系统调用上的二次封装  
## 读取文件元数据
系统提供方函数stat和fstat获取文件的信息
## 读取目录内容
opendir
## 共享文件
描述符表  
文件表  
v-node表  
-----------------2020-1-31------------  
## I/O重定向
磁盘文件和标准输入输出联系起来  
## 标准I/O
## 我们应该使用哪些I/O函数？
网络通信这块尽量别用标准库I/O函数  
# 网络编程
## 客户端-服务端编程模型

用户发起请求  
服务器接收请求，并操作资源  
服务器给客户端发一个响应  
客户端接收并处理之  

## 网络
以太网段  
桥接以太网  
软件协议---命名机制，传送机制  
数据封装
## 全球IP因特网 
### IP地址
系统函数可以做到将网络字节序转化为当前计算机字节序，也可以将ip地址转化为点分十进制串  
### 因特网域名
长的数字不好记忆，转化成域名，每次用ip地址就再转换一下  
### 因特网连接
客户端和服务端地址加端口
## 套接字接口
### 套接字地址结构
### socket函数
socket函数创建套接字描述符  
### connect函数
### bind函数
### listen函数
### accept函数
### 主机和服务的转换
-----------2020-2-1-------------------

getaddrinfo()将主机名，主机地址，服务名，端口号转化为套接字地址结构  
getnameinfo()将套接字地址结构转化为主机和服务名  

### 套接字接口的辅助函数
open_clientfd()---建立与服务器连接  
open_listenfd()---打开返回监听描述符  
### echo客户端与服务器的示例  
## web服务器
### web基础  
### web内容
### HTTP事务

# 12 并发编程
## 基于进程额并发编程
理解连接描述符和监听描述符  
### 基于进程的并发服务器
### 进程的优劣
## 基于I/O多路复用的并发模型
## 基于I/O多路复用的并发事件驱动服务器
## 基于线程的并发模型
### 线程执行模型 
### Posix线程
pthread
### 创建线程
pthread_create()---创建线程 
pthread_self()---获取本线程ID  
### 终止线程
顶层的线程返回，隐式终止  
pthread_exit()---显式终止  
某个对等线程调用linux exit()函数  
另外一个对等线程调用此线程的id作为函数pthread_cancel()的参数  
### 回收已经终止的线程资源  
thread_join()---等待指定线程终止  
### 分离线程 
可结合---能够被其他线程回收或者杀死  
可分离---不能被其他线程回收或者杀死，它的内存资源再线程终止时候被操作系统回收  
pthread_detach()---分离可结合线程  
### 初始化线程  
pthread_init()---初始化与线程历程有关的状态  
### 基于线程的并发服务器  

## 多线程中的共享变量
-------------2020-2-2----------------
### 线程内存模型  
### 将变量映射到内存  
### 共享变量  
## 用信号量同步线程
P,V操作
### 进度图
临界区  
互斥  
### 信号量
sem_init()---初始化信号量  
sem_wait()---p操作  
sem_post()---V操作  
### 使用信号量来实现互斥  
互斥锁  
### 利用信号量来调度共享资源  
生产者-消费者  
读者-写者  
第一类读写者问题---读者优先，不要让读者等待  
第二类读写者问题---写者优先，只要有写操作，就尽快让写者进行  
### 综合：基于预线程化的并发服务器
使用线程也可以做事件驱动的并发程序  
## 使用线程提高并行性
## 12.7  其他并发问题
### 线程安全
四类线程不安全函数：不保护共享变量的函数，保持跨越多个调用的状态的函数，返回指向静态变量的函数，调用线程不安全函数的函数  
### 可重用性
被多个线程调用，不会引用任何共享数据  
### 在线程化的程序中使用已存在的库函数
linux提供线程可重入函数版本，后缀加_r
### 竞争
### 死锁

finish








































