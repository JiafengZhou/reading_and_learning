# 第1章 计算机系统漫游
-------------------2020-1-9---------------
## 1.1 信息就是位+上下文
计算机系统中的信息实际上就是一堆二进制数，机器只认识二进制数，但是相同的二进制序列可能会表示不同的意义，而这些意义就是计算机系统中的各种概念。
## 1.2 程序被其他程序翻译成不同的格式
预处理-编译-汇编-链接
## 1.3 了解编译系统如何工作是有很大益处的
优化程序性能/理解链接时出现的错误/避免安全漏洞
## 1.4 处理器读取并解释存储在内存中的指令
系统的硬件组成---总线，I/O设备，主存，处理器
## 1.5 高速缓存至关重要
利用好高速缓存可以将应用程序提速很多倍
## 1.6 存储设备形成层次结构
存储区层次结构
## 1.7 操作系统管理硬件
进程，线程，虚拟内存，文件
## 1.8 系统之间利用网络进行通信
线程级并发  
指令级并行  
单指令多数据并行

# 2 信息的表示与处理
## 2.1 信息存储
### 十六进制表示法  
### 字数据大小  
### 寻址与字节顺序：大端法，小端法  
测试程序  
chapter1：
void show_bytes(byte_pointer start, size_t len);

void show_int(int x);

void show_float(float x);

void show_pointer(void* x);

void test_bytes();       //测试系统大段小端

### 表示字符串
### 表示代码
相同的C函数在不同的机器，会编译出不同的指令和编码方式
### 布尔代数
可以通过一些二进制布尔运算来表示数据集的交，并关系
### C语言中的位级运算
&，|，~，^
### C语言中的逻辑运算
&&，||，！
### C语言中的移位运算

## 2.2 整数表示
### 整型数据类型
### 无符号数编码
无符号数编码是唯一的
### 补码编码
补码编码是唯一的  
注意补码的计算公式  
### 符号数和无符号数之间的转换
### C语言中的有符号数与无符号数
-----------------2019-1-10-------------------
数据的二进制表述没有变，只是改变了编码表述，是补码还是无符号数
### 拓展一个数字的位表示
C语言将低字数无符号数据类型转换为大字数有符号数据类型，先扩充补码的二进制位数，用最高位填充，再用有符号数来解释
### 截断数字
无符号数截断需要用原来的无符号数模2的需要截断的位数次方  
有符号数截断：先使用无符号数的截断方法去截断数据，在将截断剩下的二进制数转化位有符号数表示
### 关于有符号数和无符号数的建议

## 2.3 整数运算
### 无符号加法
固定位数的算数加法有造成溢出的风险  
检测无符号数加法的溢出原理  
无符号数求反
### 补码加法
正溢出    
负溢出  
补码加法的溢出检测原理  
### 补码的非
补码的非
额外两种计算补码非的算法
### 无符号数乘法
### 补码乘法
无符号数乘法和补码乘法的位级等价
### 乘以常数
乘以2的幂的无符号数---左移  
乘以2的幂的补码---左移  
乘以任意整数---将其分解为多个2的指数幂次相加，依次左移相加相减
### 除以2的幂
无符号数右移除以2的k次幂，向下取整  
有符号数右移，使用算数移位，向下取整  
如果想求向上取整的结果，应该在移位之前加入一些偏移
### 关于整数运算的一些思考
越界很危险

## 2.4 浮点数
### 二进制小数
类似于十进制
### IEEE浮点表示
符号，尾数，阶码  
规格化的值，非规格化的值，特殊值---无穷大或NAN
### 数字表示
### 舍入
最近值舍入  
向零舍入  
向下舍入  
向上舍入  
### 浮点运算
浮点运算的乘法没有结合律和分配律
### C语言中的浮点数
C语言不强制要求机器满足IEEE浮点数标准  
-------------2020-1-11------------------  
# 3 程序的机器级表示
## 3.1 历史观点  
指令集在伴随硬件的发展更替，新的系统可以对以前的特性兼容，但是很多原来的指令集现在看都是过时的
## 3.2 程序编码
源代码->(预处理器)->替换宏的源代码->(编译器)->汇编代码->(汇编器)->目标代码->(连接器)->可执行文件
### 机器级代码
程序计数器---给出下一条要执行程序的地址  
整数寄存器文件---16个寄存器，用于存储地址或者整数数据  
条件码寄存器---保存最近执行的算术和逻辑指令的状态信息  
一组向量寄存器---存放一个或多个整数或浮点数  
### 代码示例
x86-64指令集长度从1-15不等，用的多的指令所占字节数少  
## 3.3 数据格式
汇编代码后面的后缀会指定传输数据的类型，占用的位数
## 3.4 访问信息
x86-64指令集：16个64位通用目的寄存器---存放整数和指针
### 操作数指示符
操作数分为：立即数，寄存器，内存引用  
各种寻址方式  
### 数据传送指令
move指令  
movez系列零拓展
moves系列符号拓展
### 数据传输示例
练习使用汇编代码往C源代码反向工程
### 压入和弹出栈数据
栈顶元素的地址是栈中元素地址最底的  
%rsp寄存器是存放栈指针的  
## 3.5 算数和逻辑操作
加载有效地址，一元操作，二元操作，移位  
### 加载有效地址
leap指令
### 一元和二元操作
### 移位操作
### 讨论
### 特殊的算数操作
-------------2020-1-12---------------------
128位乘法和除法的拓展运算  
%rdx作为高位，%rax作为低位  
## 3.6 控制
### 条件码
条件码寄存器  
ZF---零标志  
CF---进位标志  
SF---符号标志  
OF---溢出标志 

比较和测试指令组合

### 访问条件码
设置指令集
### 跳转指令 
跳转指令集
### 跳转指令的编码
相对寻址和绝对寻址(目测相对寻址用的多)
### 用条件控制来实现条件分支
正常逻辑判断跳转
### 用条件传送实现条件分支
因为现代处理器使用流水线技术，因此使用条件传输往往可以获得高性能，但是不绝对，因为条件传送会计算两种情况变量值，如果计算量比较大，就没有条件控制高效。
### 循环
do-while循环  
-----------------2020-1-13---------------  
while循环---两种翻译方法：跳转到中间；guarded do;  
for循环  

### switch语句
跳跃表  
## 3.7 过程
### 运行时栈
用栈来保存过程调用机制的参数
### 转移控制
call  
ret
使用栈来保存调用函数的数据，在被调用函数之间跳来跳去
### 数据传送
如果输入参数数量大于6，要使用栈来保存其他的输入参数，一个参数在地址上占据八位
### 栈上的局部存储
由于寄存器数量不足，局部变量使用&或者局部变量是数组或者结构，需要将变量放在内存中存储
### 寄存器中的局部存储空间
%rbx,%rbp,%12-%r15被调用者保存寄存器---调用过程必须为这些寄存器的数据提供栈空间存储或者在调用过程的过程中不改变这些寄存器的数据  
其他的寄存器除了%rsp之外叫做调用者保存寄存器，调用者必须为

## 3.8 数组分配和访问

### 基本原则
基本的指针索引
### 指针运算
### 嵌套数组
类似于数据结构中的表述
### 定长数组
------------------2020-1-14-------------  
定长数组O1项优化实际上是做了编译期计算，增加了编译期计算时间，但是降低了运行期计算时间。  
### 变长数组
GCC如果编译使用优化项，可以识别多维变长数组中的步长，产生的代码可以避免一些乘法计算，从而提高程序的性能。
## 3.9 异质的数据结构
### 结构
存储方式类似于指针，只不过内部类型可以不同，内部变量的引用可以在结构体指针的基础上加上偏移得到
### 联合
节省空间的方法
### 数据对齐
数据对齐可以提高内存系统性能：比如书如果不对齐，数据存在两个相邻的字节中，cpu需要从内存中取两次数据，分别是两个字节的高位数据和低位数据，拼起来，但是如果数据是对齐的，一次就可以取出，这样就提高了系统效率。当使用数据对齐时候，有时候需要做数据填充，来保证数据对齐。
## 3.10 在机器级程序中将控制与数据结合起来
### 理解指针
参考c primer plus
### 应用：使用GDB调试器

### 内存越界引用和缓冲区溢出
系统安全漏洞的重要来源
### 对抗缓冲区溢出攻击
栈随机化，栈破坏检测，限制可执行代码区域
### 支持变长栈帧
加了一个帧指针
## 3.11 浮点代码
MMX-SSE-AVX  
### 浮点传送和转换操作
--------------2020-1-15--------------
### 过程中的浮点代码
根据函数的输入参数的顺序和数量决定哪些参数在那个寄存器哪些参数在栈中
### 浮点运算操作
加减乘除最大最小平方
### 定义和使用浮点常数
### 浮点数代码中的位级操作
位级异或位级与
### 浮点比较操作
### 对浮点代码的观察结论










